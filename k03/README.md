# 課題3 レポート
学生番号 35319053　氏名 山口陸


## 課題  

以下の2つのアルゴリズムで文字列を検索するプログラムを作成する。  
- 力ずく法
- BM法

1. 使用するデータ  
以下のデータを使用する。ただし、検索対象文字列、検索する文字列は変更しても良い。  
    - StrOriginal: 検索対象データ
    - StrKey: 検索する文字列

2. 必須問題：実装する関数  
本課題では、以下の関数を実装する。C言語の標準ライブラリは使用しないこと。  
    (1) ForceSearch: 力ずく法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  

    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

    (2) BMSearch: BM法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  
 
    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

3. 補助関数  
なし

## ソースコードの説明
17,18行目でtextとkeyの文字数を数える
20~32行目のfor文は比較が成功するまで比較場所を一つずつずらしながら繰り返す。
21~31行目のfor文はkeyがtextにあるかどうかを繰り返し比較する。
22行目からのif文はkeyの最初の文字から比較していき、途中で比較に失敗したら、24行目のelseに行き、for文から外れる。比較に成功するたびにaに1を足していき、aがkey_lenに達するとForceSearchの関数が&text[pos]を返す。
32行目でaをリセットする。

43,44行目でtext,keyの文字を数える。
47~49行目でとりあえずtableの数字をすべてkey_lenと同じ数字にし、50~52行目で文字ごとのずらす量を決める。
56行目のfor文では、indexをkey_len-1にし、比較が失敗する度にindexにtableを足していく。
57行目はindexをindexAにひとまず保存しておく。
58行目からはtextの比較部分とkeyの比較部分を比較していき、同じ文字だった場合textとkeyの比較部分を一つ戻し、違う場合はfor文から抜ける。keyがすべて一致した場合は&text[index]を返す。
しかしこのままでは比較場所が戻ってしまい、無限ループしてしまう可能性が出てくるため、68行目で57行目で保存したindexAを使い、比較場所を前回の次の文字になるようにする。
73行目はtextにkeyがなかった時にNULLを返す。


## 出力結果

```
Force Search. Find keyword at:wind in my hair.
BM Search. Find keyword at:wind in my hair.

```

## 修正履歴

